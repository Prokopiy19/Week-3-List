# my_list.h

В списке я использую dummy-узел, который хранится в поле структуры MyList. dummy.next указывет на первый узел. Хранение dummy имеет двумя недостатками: увеличивает размер списка примерно на sizeof(T) и может вызывать CE, если тип элемента T не является default-constructible. Чтобы исправить эти 2 недостатка, я разбил ListNode на базовую структуру ListNodeBase и наследника ListNode. ListNodeBase хранит только указатель на следующий узел, a ListNode хранит сам элемент value. dummy будет типа ListNodeBase. Мы используем static_cast<ListNode*> для каждого обращения к полю value, и когда удаляем узел (особенно важно). Очевидно, static_cast<ListNode*> не применяем к dummy.

Для инкапсуляции и скрытия внутренней структуры списка я реализовал итераторы (и константную, и мутабельную). Итераторы обладают свойствами forward_iterator.

Мой список можно использовать с алгоритмами стандартной библиотеки, а также с range-for.

Поддерживается push_front, pop_front, insert_after, erase_after.

Мой список не хранит указатель tail, чтобы не поддерживать его после каждого вызова insert_after и erase_after. Следовательно, мой список не поддерживает push_back и pop_back. Пользователю нужно вручную добраться до конца и добавлять и удалять элементы.

В основном реализовал только методы, которые требовались в домашнем задании.
